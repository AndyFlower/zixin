1、谈谈对volatile的理解
①、volatile是java虚拟机提供的轻量级的同步机制（同步比如synchronized）拥有3大特性：保证可见性；不保证原子性；禁止指令重排
保证可见和有序并不保证原子性。
VolatileDemo.java
通过代码的演示我们可以看到对主存中共享变量的操作都是各个线程拷贝到自己额工作内存进行操作后再写回到主内存中，
这就可能存在一个线程AAA修改了共享变量X的值但还未写回主内存时，另外一个线程BBB又对主内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。

使用javap将T1编译出字节码
Compiled from "T1.java"
public class com.zishen.T1 {
  volatile int a;

  public com.zishen.T1();
    Code:
       0: aload_0                            //从局部变量0中装载引用类型的值
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: aload_0
       5: iconst_1
       6: putfield      #2                  // Field a:I
       9: return

  public void add();
    Code:
       0: aload_0
       1: dup                               //
       2: getfield      #2                  // Field a:I
       5: iconst_1
       6: iadd
       7: putfield      #2                  // Field a:I
      10: return
}
2-分析字节码++.png
因为++指令实际上是分成3个指令执行的，所以会出现写丢失的情况，也就是写覆盖。

有序性：
计算机在执行时，为了提高性能，编译器和处理器常常会对指令做重排，分三种：
3-指令重排.png
单线程环境里面确保程序最终执行结果和代码顺序执行的一致性。
处理器在进行重排序时必须考虑指令之间的数据依赖性。
多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

理解这个，需要先了解一下内存屏障的概念：
内存屏障（Memory Barrier）又叫内存栅栏,是一个CPU指令，他的作用有2个：
一是保证特定操作的顺序执行
二是保证某些变量的内存可见性
由于编译器个处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。
内存屏障另外一个作用的强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

volatile实现了禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象。
4-volatile读写.png

线程安全性如何获得保证：
①、工作内存与主内存同步延迟现象导致的可见性问题
可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见
②、对于指令重排导致的可见性问题和有序性问题
可以利用volatile关键性解决，因为volatile的另外一个作用就是禁止重排序优化。

哪些情况下使用到volatile
①、单例模式DCL代码
SingletonDemo.java
DCL机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排。
原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。
instance = new SingletonDemo();可以分为以下3步完成。

memory=allocate();//1、分配对象内存空间
instance(memory);//2、初始化对象
instance=memory;//3、设置instance指向刚分配的内存地址，此时instance!=null

步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后的执行结果在单线程中并没有改变。因此这种重排优化是允许的。

memory=allocate();//1、分配对象内存空间
instance=memory;//3、设置instance指向刚分配的内存地址，此时instance!=null 但是对象还没有初始化完成。
instance(memory);//2、初始化对象
但是指令重排只会保证串行语义的执行的一致性（单线程），但并不会关系多线程间的语义一致性。
所以当一条指令访问instance不为null时，由于instance实例已初始化完成，也就造成了线程安全问题。


②、单例模式volatile分析


2、谈谈JMM（java内存模型 Java Memory Model）
本身是一种抽象的概念，描述的是一种规则或规范，通过程序中各个变量（实例字段、静态字段、和构成数组对象中的元素）的访问方式。
JMM关于同步的规定：
①、线程解锁前，必须把共享变量的值刷新回主内存
②、线程加锁前，必须读取主内存中的最新值到自己的工作内存
③、加锁解锁是同一把锁
由于JMM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java
内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要
将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存
储着主内存中的变量副本拷贝，因此不通的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其访问过程如图。
1-JMM访问.png
JMM有三大特性：
2.1、可见性
2.2、原子性
2.3、有序性