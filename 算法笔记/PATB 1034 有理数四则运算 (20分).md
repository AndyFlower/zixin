## 1034 有理数四则运算 (20分)

### 题目描述

本题要求编写程序，计算 2 个有理数的和、差、积、商。

### 输入描述:

输入在一行中按照 `a1/b1 a2/b2` 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。

### 输出描述:

分别在 4 行中按照 `有理数1 运算符 有理数2 = 结果` 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 `k a/b`，其中 `k` 是整数部分，`a/b` 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 `Inf`。题目保证正确的输出中没有超过整型范围的整数。

### 输入例子:

```
2/3 -4/2
```

### 输出例子

```
2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)

```

### 输入例子:

```
5/3 0/6

```

### 输出例子

```
1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf

```

### 

### 代码

```java
package com.zixin.algorithm;

import java.util.HashMap;
import java.util.Scanner;

public class PATB1033 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		HashMap<Character, Character> ha = new HashMap<Character, Character>();
		char[] s = sc.next().toCharArray();
		char[] res = sc.next().toCharArray();// 真实输入的字符串
		sc.close();
		StringBuilder sb = new StringBuilder("");
		for (int i = 0; i < s.length; i++) {
			ha.put(Character.toLowerCase(s[i]), Character.toLowerCase(s[i]));// 将所有坏掉的键放入map中
		}
		if (ha.containsKey('+')) {
			for (int i = 0; i < s.length; i++) {
				ha.put(s[i], s[i]);
			}
		}
		if(ha.containsKey('+')) {
			for (int j = 0; j < res.length; j++) {
				if(ha.containsKey(res[j])||(res[j]>=65&&res[j]<=90)) {
					continue;
				}else {
					sb.append(res[j]);
				}
			}
		}else {
			for (int j = 0; j < res.length; j++) {
				if(ha.containsKey(res[j])) {
					continue;
				}else {
					sb.append(res[j]);
				}
			}
		}
	
		System.out.println(sb.toString());
	}

}



```





### 输入VS输出

```java
7+IE.
7_This_is_a_test.
_hs_s_a_tst

```

### 提交

![PATB1033提交](D:/slpworkspace/github/2020/算法笔记/image/PATB1033提交.png)

有一个点错误和一个超时，暂时未找到原因

以下代码来自网络，可以A:https://blog.csdn.net/TonyHTY/article/details/102670726

```java
package not.die.in.here;
import java.io.*;
import java.util.Arrays;
 
public class _1033_BrokenkeyType {
 
	public static void main(String[] args) throws IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));//buff加快读取速度
		 //StreamTokenizer st = new StreamTokenizer(bf);这个还没有完全搞懂，不过好像这玩意能更快
		String temp = bf.readLine();
		char[] broken = (temp+temp.toLowerCase()).toCharArray();//记录坏键
		//这里是个加快的原因，因为坏键撑死一百以内个，所以这里直接把所有的键位对应小写都变成坏键，并不会增加多少循环
		//后面直接比对就好了
		char[] type = bf.readLine().toCharArray();//记录需要打的键
		StringBuilder sb = new StringBuilder("");//用这个string变量来添加，比String块太多了，也比每次比对完就输出要快，输出很费事的
		Arrays.sort(broken);//因为要使用二分查找，所以先排序，默认字典顺序
		if(Arrays.binarySearch(broken, '+')==-1) {//判断是否大小写
			//大小写没坏，可以输出大写字母
			for(int i=0;i<type.length;i++) {
				if(Arrays.binarySearch(broken,type[i])<0) {
					sb.append(type[i]);//不是坏键，原样添加
				}
			}
		}
		else {//不可以输出大写字母
			for(int i=0;i<type.length;i++) {
				if((64<type[i] && type[i]<91)) {
					continue;//大写字母直接跳过
				}else {
					if(Arrays.binarySearch(broken,type[i])<0)
						sb.append(type[i]);	//这里的肯定不是大写字母，直接输出
				}
			}
		}
		System.out.println(sb);//输出结果
	}
}
```

