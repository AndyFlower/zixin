# 类加载

> 在Java中,类型的加载、连接与初始化过程是在程序**运行期间**完成的.
>
> 提供了更大的灵活性，增加了更多的可能性.

[^运行期间]: Runtime的概念。

![11、类加载过程](pic/11、类加载过程.png)

- 加载：查找并加载类的**二进制数据**，常见的有将已经存在的字节码文件加载到内存。

- 连接：
  - 验证：确保被加载的类的正确性
  - 准备：为类的静态变量分配内存，并将其初始化为默认值
  - 解析：把类中的符号引用转换为直接引用

- 初始化：为类的**静态变量**赋予正确的**初始值**
- 使用
- 卸载

## 类加载器深入剖析

### Java虚拟机与程序的生命周期

- 在如下几种情况，Java虚拟机将结束生命周期
  - 执行了`System.exit()`方法
  - 程序正常执行结束
  - 程序在执行过程中遇到了异常或错误而异常终止
  - 由于操作系统出现错误而导致Java虚拟机进程终止。

- Java程序对类的使用方式可分为两种：

  - 主动使用（7种）
    - 创建类的实例
    - 访问某个类或接口的静态变量（`getstatic`），或者对该静态变量赋值(`putstatic`)
    - 调用类的静态方法(`invokestatic`)
    - 反射（eg:`Class.forName("")`）;
    - 初始化一个类的的子类
    - Java虚拟机启动时被标明为启动类的类
    - `JDK1.7`开始提供的动态语言支持`java.lang.invoke.MethodHandle`实例的解析结果`REF_getStatic`,`REF_putStatic`,`REF_invokeStatic`句柄对应的类没有初始化，则初始化.
  - 被动使用
    - 除上述几种情况以外

  ```java
  package com.zixin.classloader;
  
  /**
   * 对于静态字段来说，只有直接定义了该字段的类才会被加载。
   * 当一个类在初始化时，要求其父类全部都已经初始化完毕。
   */
  public class Test {
      public static void main(String[] args) {
          /**
           * Parent static block
           * Hello world
           */
          System.out.println(Son.str);
          /**
           * Parent static block
           * son static block
           * Welcome
           *
           * 子类初始化的时候要保证父类也都初始化完成
           */
          System.out.println(Son.str2);
      }
  }
  
  class Parent{
      public static String str="Hello world";
      static {
          System.out.println("Parent static block");
      }
  }
  
  class Son extends Parent{
      public static String str2="Welcome";
      static{
          System.out.println("son static block");
      }
  
  }
  
  ```

  

​    所有的java虚拟机实现必须在每个类或接口被Java程序**首次主动使用**时才初始化他们

### 类的加载

类的加载指的是将类的.class文件中的二进制数据读入导内存中，将其放在运行时数据区的方法区中，然后在内存中创建一个`java.lang.Class`对象(规范中未说明Class对象位于哪里，`HotSpot`虚拟机将其放在了方法区中)用来封装类在方法区内的数据结构。

#### 加载.class文件的方式

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip,jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件

#### 使用`-XX:+TraceClassLoading`查看类加载顺序

```java
-XX:+TraceClassLoading：用于追踪类的加载信息并打印出来

 -XX:+<option>:表示开启option选项
 -XX:-<option>:表示关闭option选项
 -XX：<option>=<value>:表示将option选项的值设置为value
```

![12、TraceClassLoading](pic/12、TraceClassLoading.png)

![13、类加载顺序](pic/13、类加载顺序.png)

#### 常量的本质含义及反编译助记符

```java
package com.zixin.classloader;

/**
 * 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中
 * 本质上，调用类并没有直接引用到这个定义常量的类，因此不会触发定义常量的类的初始化
 * 注意：这里指的是将常量存放到了Test2的常量池中，之后Test2与Parent1就没有任何关系了，甚至，我们可以将Parent1的class文件删除
 *
 * 助记符：
 * ldc表示将int  float或是String类型的常量值从常量池中推送到栈顶
 * bipush表示将单字节的常量值-128~127推送至栈顶
 * sipush表示将一个短征信常量值（-322768~32767）推送至栈顶
 * iconst_1表示将int类型的1推送至栈顶(iconst_m1~iconst_5)
 */
public class Test2 {
    public static void main(String[] args) {
        /**
         * s加final修饰  hello world
         * s不加final修饰：parent1 static block
         *                hello world
         */
        System.out.println(Parent1.s);
    }

}
class Parent1{
    public static final String s = "hello world";
    public static final int i = 1;
    public static final Short sh = 127;
    static {
        System.out.println("parent1 static block");
    }
}
```

![14、常量助记符](pic/14、常量助记符.png)

![15、常量助记符-int](pic/15、常量助记符-int.png)

#### 编译器常量和运行期常量

```
package com.zixin.classloader;

import java.util.UUID;

/**
 * 当一个常量的值并非编译器间可以确定的，那么其值就不会被放到调用类的常量池中，
 * 这是在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化
 */
public class Test3 {
    public static void main(String[] args) {
        /**
         * Parent3 static code
         * 41724e87-f67c-4e0d-8604-ccbf7d57cb56
         */
        System.out.println(Parent3.s);
    }
}

class Parent3{
    public static  final String s=UUID.randomUUID().toString();
    static {
        System.out.println("Parent3 static code");
    }

}
```

#### 数组创建本质分析

```java
package com.zixin.classloader;

/**
 *对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.zixin.classloader.Parent4
 * 这种形式，动态生成的类型，父类型都是object
 *
 * 对于数组来说，JavaDoc经常讲构成数组的元素称为Component,实际上就是将数组将第一个维度后的类型
 *
 * 助记符：
 * anewarray:表示创建一个引用类型的数组，并将其引用值压入栈顶
 * newarray:表示创建一个袁术类型的数组，并将其引用值压入栈顶
 */
public class Test4 {
    public static void main(String[] args) {
        /**
         * 主动使用第一种情况：创建类的实例：
         *     Parent4 static block
         */
        //Parent4 parent4 = new Parent4();
        /**
         * 不会输出
         */
        Parent4[] parent4s= new Parent4[1];
        //class [Lcom.zixin.classloader.Parent4; 由java虚拟机在运行过程中创建的
        System.out.println(parent4s.getClass());
        //class java.lang.Object
        System.out.println(parent4s.getClass().getSuperclass());
        Parent4[][] parent4s1= new Parent4[1][1];
        //class [[Lcom.zixin.classloader.Parent4;
        System.out.println(parent4s1.getClass());
        //class java.lang.Object
        System.out.println(parent4s1.getClass().getSuperclass());

        System.out.println("-----");
        int[] ints = new int[1];
        //class [I
        System.out.println(ints.getClass());
        //class java.lang.Object
        System.out.println(ints.getClass().getSuperclass());
    }
}

class Parent4{
    static {
        System.out.println("Parent4 static block" );
    }
}

```

